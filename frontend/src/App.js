import React, { useEffect, useRef, useState } from 'react';
import './App.css';
import axios from "axios";

const App = () => {
  const [chat, setChat] = useState([]);
  const [status, setStatus] = useState("‚ñ∂Ô∏è ‡≤Ü‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤≤‡≥Å ‡≤∏‡≥ç‡≤ü‡≤æ‡≤∞‡≥ç‡≤ü‡≥ç‚Äå ‡≤¨‡≤ü‡≤®‡≥ç‚Äå ‡≤í‡≤§‡≥ç‡≤§‡≤ø");
  const [appState, setAppState] = useState("idle"); // idle | listening | processing | speaking
  const [showFeedback, setShowFeedback] = useState(false);
  const [feedbackText, setFeedbackText] = useState("");
  const [hasInteracted, setHasInteracted] = useState(false);


  const mediaRecorderRef = useRef(null);
  const audioChunksRef = useRef([]);
  const isRunningRef = useRef(false);
  const silenceTimerRef = useRef(null);
  const audioContextRef = useRef(null);
  const sourceRef = useRef(null);
  const analyserRef = useRef(null);
  const dataArrayRef = useRef(null);
  const volumeHistory = useRef([]);


  const startRecording = async () => {
    setShowFeedback(false);  // Hide feedback box if visible
    setFeedbackText("");     // Clear old feedback
    setHasInteracted(true);  // ‚úÖ user interacted at least once


    setAppState("listening");
    setStatus("üé§ ‡≤ß‡≥ç‡≤µ‡≤®‡≤ø‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤ï‡≥á‡≤≥‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...");
    isRunningRef.current = true;
    audioChunksRef.current = [];
    volumeHistory.current = [];

    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioContextRef.current = new AudioContext();
    sourceRef.current = audioContextRef.current.createMediaStreamSource(stream);
    analyserRef.current = audioContextRef.current.createAnalyser();
    sourceRef.current.connect(analyserRef.current);
    dataArrayRef.current = new Uint8Array(analyserRef.current.fftSize);

    detectSilence();

    const recorder = new MediaRecorder(stream);
    mediaRecorderRef.current = recorder;

    recorder.ondataavailable = (e) => {
      if (e.data.size > 0) {
        audioChunksRef.current.push(e.data);
      }
    };

    recorder.onstop = async () => {
      isRunningRef.current = false;

      if (audioChunksRef.current.length === 0) return;

      const avgVolume = volumeHistory.current.reduce((a, b) => a + b, 0) / volumeHistory.current.length;
      if (avgVolume < 5) {
        setStatus("‚ö†Ô∏è ‡≤ß‡≥ç‡≤µ‡≤®‡≤ø ‡≤™‡≤§‡≥ç‡≤§‡≥Ü‡≤Ø‡≤æ‡≤ó‡≤ø‡≤≤‡≥ç‡≤≤.");
        setAppState("idle");
        return;
      }

      const blob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
      const formData = new FormData();
      formData.append('file', blob, 'audio.webm');

      setAppState("processing");
      setStatus("üîÑ ‡≤™‡≥ç‡≤∞‡≤ï‡≥ç‡≤∞‡≤ø‡≤Ø‡≥Ü ‡≤®‡≤°‡≥Ü‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...");

      try {
        const res = await fetch('http://localhost:8000/voice', {
          method: 'POST',
          body: formData,
        });

        const data = await res.json();
        setChat((prev) => [...prev, { user: data.user_text, bot: data.bot_text }]);

        setAppState("speaking");
        setStatus("ü§ñ ‡≤â‡≤§‡≥ç‡≤§‡≤∞ ‡≤®‡≥Ä‡≤°‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...");

        const audio = new Audio(data.audio_url);
        audio.play();

        audio.onended = () => {
          setStatus("üßπ ‡≤∂‡≥Å‡≤¶‡≥ç‡≤ß‡≤ó‡≥ä‡≤≥‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...");

          axios.post("http://localhost:8000/force_cleanup")
            .then(res => {
              console.log("[CLEANUP] Done:", res.data);
            })
            .catch(err => {
              console.error("[CLEANUP] Failed:", err);
            })
            .finally(() => {
              setStatus("üé§ ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤ï‡≥á‡≤≥‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...");
              startRecording(); // Repeat
            });
        };
      } catch (err) {
        console.error('‚ùå Backend error:', err);
        setStatus("‚ùå ‡≤¶‡≥ã‡≤∑‡≤µ‡≤æ‡≤Ø‡≤ø‡≤§‡≥Å.");
        setAppState("idle");
      }
    };

    recorder.start();
  };

  const stopRecording = async () => {
    setAppState("idle");
    setStatus("üõë ‡≤ß‡≥ç‡≤µ‡≤®‡≤ø ‡≤®‡≤ø‡≤≤‡≥ç‡≤≤‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü...");
    isRunningRef.current = false;
    setShowFeedback(true); // üëà Show feedback section

    if (mediaRecorderRef.current?.state === "recording") {
      mediaRecorderRef.current.stop();
    }

     if (audioContextRef.current && audioContextRef.current.state !== "closed") {
    try {
      await audioContextRef.current.close();
      audioContextRef.current = null; // clear reference
    } catch (err) {
      console.warn("‚ö†Ô∏è AudioContext close error:", err.message);
    }
  }

    clearTimeout(silenceTimerRef.current);

    try {
      const res = await axios.post("http://localhost:8000/clear_chat");
      console.log("[CLEAR] Response from server:", res.data);
    } catch (err) {
      console.error("[CLEAR] Failed to clear chat history:", err);
    }
  };

  const detectSilence = () => {
    const checkSilence = () => {
      if (!analyserRef.current) return;

      analyserRef.current.getByteTimeDomainData(dataArrayRef.current);
      const maxVolume = Math.max(...dataArrayRef.current);
      const normalized = Math.abs(maxVolume - 128);
      volumeHistory.current.push(normalized);

      if (normalized < 5) {
        if (!silenceTimerRef.current) {
          silenceTimerRef.current = setTimeout(() => {
            stopRecording();
          }, 2000);
        }
      } else {
        if (silenceTimerRef.current) {
          clearTimeout(silenceTimerRef.current);
          silenceTimerRef.current = null;
        }
      }

      if (isRunningRef.current) {
        requestAnimationFrame(checkSilence);
      }
    };

    requestAnimationFrame(checkSilence);
  };

  useEffect(() => {
    return () => stopRecording();
  }, []);

  const renderStatusAnimation = () => {
    switch (appState) {
      case "listening":
        return <div className="status-box listening">üé§ ‡≤ï‡≥á‡≤≥‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...</div>;
      case "processing":
        return <div className="status-box processing">üîÑ ‡≤™‡≥ç‡≤∞‡≤ï‡≥ç‡≤∞‡≤ø‡≤Ø‡≥Ü ‡≤®‡≤°‡≥Ü‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...</div>;
      case "speaking":
        return <div className="status-box speaking">üó£Ô∏è ‡≤â‡≤§‡≥ç‡≤§‡≤∞ ‡≤®‡≥Ä‡≤°‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...</div>;
      default:
        return <div className="status-box idle">‚ñ∂Ô∏è ‡≤Æ‡≤æ‡≤§‡≤®‡≤æ‡≤°‡≤≤‡≥Å ‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤ø ‡≤¨‡≤ü‡≤®‡≥ç ‡≤í‡≤§‡≥ç‡≤§‡≤ø</div>;
    }
  };

  return (
    <div className="app-container">
      <div className="caution-footer">
        
        ‚ö†Ô∏è ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü: ‡≤à ‡≤ö‡≤æ‡≤ü‡≥ç‚Äå‡≤¨‡≤æ‡≤ü‡≥ç ‡≤â‡≤§‡≥ç‡≤§‡≤∞‡≤ó‡≤≥‡≥Å ‡≤Ø‡≤æ‡≤µ‡≤æ‡≤ó‡≤≤‡≥Ç ‡≤®‡≤ø‡≤ñ‡≤∞‡≤µ‡≤æ‡≤ó‡≤ø‡≤≤‡≥ç‡≤≤. ‡≤§‡≤™‡≥ç‡≤™‡≤æ‡≤¶ ‡≤Æ‡≤æ‡≤π‡≤ø‡≤§‡≤ø ‡≤∏‡≤æ‡≤ß‡≥ç‡≤Ø. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤ñ‡≤ö‡≤ø‡≤§‡≤™‡≤°‡≤ø‡≤∏‡≤ø‡≤ï‡≥ä‡≤≥‡≥ç‡≤≥‡≤ø.
      </div>

      <div className="sticky-top">
        {renderStatusAnimation()}
        <div className="btn-group">
          <button onClick={startRecording}>‚ñ∂Ô∏è ‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤ø</button>
          <button onClick={stopRecording}>üü• ‡≤®‡≤ø‡≤≤‡≥ç‡≤≤‡≤ø‡≤∏‡≤ø</button>
        </div>
      </div>

      <div className="chat-container">
        {chat.map((item, i) => (
          <div key={i} className="chat-bubble">
            <p><b>üôã‚Äç‚ôÇÔ∏è ‡≤®‡≥Ä‡≤µ‡≥Å:</b> {item.user}</p>
            <p><b>ü§ñ ‡≤ú‡≤ø‡≤™‡≤ø‡≤ü‡≤ø:</b> {item.bot}</p>
          </div>
        ))}
      </div>

{hasInteracted && appState === "idle" && showFeedback && (
  <div className="feedback-overlay">
    <div className="feedback-popup">
      <h3>üí¨ ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤Ö‡≤≠‡≤ø‡≤™‡≥ç‡≤∞‡≤æ‡≤Ø‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤®‡≤Æ‡≤ó‡≥Ü ‡≤§‡≤ø‡≤≥‡≤ø‡≤∏‡≤ø:</h3>
      <textarea
        rows={4}
        placeholder="‡≤á‡≤≤‡≥ç‡≤≤‡≤ø ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤Ö‡≤≠‡≤ø‡≤™‡≥ç‡≤∞‡≤æ‡≤Ø‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤¨‡≤∞‡≥Ü‡≤Ø‡≤ø‡≤∞‡≤ø..."
        value={feedbackText}
        onChange={(e) => setFeedbackText(e.target.value)}
      />
      <div className="feedback-buttons">
        <button
          onClick={async () => {
            if (!feedbackText.trim()) return;
            try {
              await axios.post("http://localhost:8000/submit_feedback", {
                feedback: feedbackText,
                timestamp: new Date().toISOString(),
              });
              alert("üôè ‡≤ß‡≤®‡≥ç‡≤Ø‡≤µ‡≤æ‡≤¶‡≤ó‡≤≥‡≥Å! ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤Ö‡≤≠‡≤ø‡≤™‡≥ç‡≤∞‡≤æ‡≤Ø‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≤°‡≥Ü‡≤¶‡≥Å‡≤ï‡≥ä‡≤Ç‡≤°‡≥Ü‡≤µ‡≥Å.");
              setFeedbackText("");
              setShowFeedback(false);
            } catch (err) {
              alert("‚ùå ‡≤Ö‡≤≠‡≤ø‡≤™‡≥ç‡≤∞‡≤æ‡≤Ø ‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≥Å‡≤µ‡≤≤‡≥ç‡≤≤‡≤ø ‡≤¶‡≥ã‡≤∑‡≤µ‡≤æ‡≤Ø‡≤ø‡≤§‡≥Å.");
              console.error("Feedback error:", err);
            }
          }}
        >
          ‚úâÔ∏è ‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤ø
        </button>
        <button onClick={() => setShowFeedback(false)}>‚ùå ‡≤Æ‡≥Å‡≤ö‡≥ç‡≤ö‡≥Å</button>
      </div>
    </div>
  </div>
)}

    </div>
  );
};

export default App;
